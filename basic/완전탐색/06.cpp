/*
배열 기록 후 구간 정하기

다음 문제는 어떻게 푸는가?
- 6개의 사탕이 1차원 직선(1-based) 위에 놓여있다. 각 위치가 1, 7, 2, 9, 4, 10이라 했을 때, 이 중 크기가 4인 구간을 적절하게 정하여 해당 구간 안에 들어 있는 사탕의 수가 최대가 되도록 하여라. -

이 문제를 주어진 정보 그대로 푸는 것은 쉽지 않다. 구간이 주어졌을 때, 해당 구간 안에 어떤 사탕이 들어있는지를 판단하기 위해서는 각 위치에 사탕이 있었는지에 대한 정보가 필요하므로, 각각의 위치에 사탕이 있으면 1, 없으면 0을 저장하는 배열을 하나 만든다.

이제 i = 1부터 시작하여 구간의 크기가 5인 곳들 중 최대 1의 개수를 세는 완탐을 진행한다. 1차원 직선상에서는 크기가 4인 구간이 예를 들어 [1, 5] 이므로 배열에서는 연속하여 5개의 숫자를 고르는 것이 되므로 k = 5로 생각하여 진행한다. 또, 주어진 숫자 중 최댓값이 10이므로 이 값을 r이라 하면, 마지막 탐색 구간이 r로 끝날 때까지 진행한다.*/
#include <bits/stdc++.h>
using namespace std;
int r = 10, k = 5;
int arr[6] = {1, 7, 2, 9, 4, 10};
int placed[11];

int main(){
    for(int i = 0; i < 6; i++){
        placed[arr[i]] = 1;
    }
    int mx = 0;
    for(int i = 1; i < r - k + 1; i++){
        int cn = 0;
        for(int j = i; j < i + k; j++){
            cn += placed[j];
        }
        mx = max(mx, cn);
    }
    cout << mx;
}
/*이처럼 좌표 기준으로 주어지는 문제라 하더라도, 좌표의 최대 크기에 해당하는 배열을 만들어 각 위치에 적절한 숫자를 적어준 뒤 구간 단위로 완탐을 한다. */